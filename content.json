{"pages":[{"title":"Eatnug","text":"안녕하세요!","link":"/about"}],"posts":[{"title":"번역] 타입스크립트 프로젝트에서 eslint와 prettier 사용하기","text":"Robert Cooper의 ‘Using ESLint and Prettier in a TypeScript Project’를 저작자의 허가를 받고 번역한 글입니다. 타입스크립트 코드를 린트 하고 싶을때 고려할 수 있는 선택지가 크게 두가지 있는데, TSLint와 ESLint이다. TSLint는 타입스크립트 전용 린터이고, ESLint는 자바스크립트와 타입스크립트 모두를 지원한다. 타입스크립트 코어 팀은 TypeScript 2019 Roadmap에서 ‘TSLint보다 ESLint의 아키텍쳐가 성능면에서 우월하므로, 앞으로는 타입스크립트를 위한 린터 통합 제공에 있어서 ESLint에만 집중하겠다`라고 설명했다. 이러한 이유로 나는 타입스크립트 프로젝트에서 린트를 사용할 때 ESLint를 사용하기를 추천한다. ESLint를 타입스크립트와 함께 쓸 수 있도록 세팅하기우선 ESLint 사용을 위해 필요한 개발의존성을 설치한다. 1yarn add -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin 저자 주: 만약 create-react-app 으로 프로젝트를 시작했다면, eslint는 react-scripts에 의해 이미 의존성에 추가되어서, 따로 다시 설치할 필요가 없다. eslint: 핵심 ESLint 라이브러리 @typescript-eslint/parser: ESLint가 타입스크립트 코드를 린트 할 수 있도록 해주는 파서 @typescript-eslint/eslint-plugin: 타입스크립트를 타겟으로 하는 ESLint 규칙들을 포함하고 있는 플러그인 다음으로, .eslintrc.js 설정 파일을 프로젝트 루트 디렉토리에 만든다. 타입스크립트 프로젝트를 위한 설정파일의 예시는 다음과 같다. 1234567891011/* .eslintrc.js */module.exports = { parser: '@typescript-eslint/parser', // ESLint 파서를 지정한다. extends: [ 'plugin:@typescript-eslint/recommended', // @typescript-eslint/eslint-plugin 규칙을 사용한다. ], rules: { // ESLint 규칙을 작성한다. 앞서 extend 한 규칙들을 덮어쓸 수 도 있다. // 예시 &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;off&quot;, },} 저자 주: 나는 .eslintrc 파일을 .js 확장자로 선언하는 것을 선호하는데, .json 파일은 필요할 때 규칙에 대한 주석을 달 수 없기 때문이다. 만약 타입스크립트와 함께 리액트를 사용한다면, eslint-plugin-react도 설치되어야 하고, 설정 파일은 다음과 같이 작성할 수 있다. 12345678910111213141516171819202122/* .eslintrc.js */module.exports = { parser: '@typescript-eslint/parser', // ESLint 파서를 지정한다. extends: [ 'plugin:react/recommended', // @eslint-plugin-react 의 규칙을 사용한다. 'plugin:@typescript-eslint/recommended', // @typescript-eslint/eslint-plugin 의 규칙을 사용한다. ], parserOptions: { ecmaFeatures: { jsx: true, // jsx의 파싱을 허용한다. }, }, rules: { // ESLint 규칙을 작성한다. extends 한 규칙들을 덮어쓸 수 도 있다. // 예시 &quot;@typescript-eslint/explicit-function-return-type&quot;: &quot;off&quot;, }, settings: { react: { version: 'detect', // eslint-plugin-react에게 사용하고 있는 리액트의 버전을 알아서 탐지하도록 한다. }, },} 궁극적으로 .eslintrc.js 파일의 rules 객체에 어떤 규칙을 사용하고, 어디에서 규칙을 extend할 것 인지는 당신의 자유이다. Prettier 까지 추가하기코드를 포매팅해주는 도구인 prettier는 ESLint와 조합이 아주 좋다. prettier를 ESLint와 함께 사용하기 위해서는 다음과 같은 개발의존성들을 설치해야한다. 1yarn add -D prettier eslint-config-prettier eslint-plugin-prettier prettier: 핵심 prettier 라이브러리 eslint-config-prettier: prettier와 충돌할 수 있는 ESLint 규칙을 비활성화 해주는 도구 eslint-plugin-prettier: prettier를 ESLint의 규칙으로 사용하기 위한 도구 prettier를 설정하기 위해서, .prettierrc.js 파일을 프로젝트 루트 디렉토리에 만들어야 한다. 예시는 다음과 같다. 12345678/* .prettierrc.js */module.exports = { semi: true, trailingComma: 'all', singleQuote: true, printWidth: 120, tabWidth: 4,} 다음으로 .eslintrc.js 파일을 수정해야한다. 123456789101112131415161718/* .eslintrc.js */module.exports = { parser: '@typescript-eslint/parser', // ESLint 파서를 지정한다. extends: [ 'plugin:react/recommended', // @eslint-plugin-react의 규칙을 사용한다. 'plugin:@typescript-eslint/recommended', // @typescript-eslint/ eslint-plugin의 규칙을 사용한다. 'prettier/@typescript-eslint', // eslint-config-prettier를 사용해서 @typescript-eslint/eslint-plugin의 규칙들 중 prettier와 충돌하는 규칙을 비활성화한다. 'plugin:prettier/recommended', // eslint-plugin-prettier와 eslint-config-prettier를 활성화한다. prettier 에러를 eslint 에러로 표시해 줄 것이다. 이 설정은 반드시 extends 배열의 마지막 값이어야 한다. ], parserOptions: { ecmaVersion: 2018, // 모던 ES의 파싱을 허용한다. sourceType: 'module', // import의 사용을 허용한다. },} 저자 주: plugin:prettier/recommended는 반드시 extends 배열의 마지막 값이어야 한다. eslint-plugin-prettier를 사용해 prettier를 ESLint의 규칙으로 설정해두면, --fix 옵션을 걸고 ESLint를 실행할때 린트 에러 뿐 아니라 prettier 에러까지 수정해주기 때문에 자동으로 포매팅이 된다. VS Code에서 자동으로 코드 수정하기좋은 개발 경험을 위해서는, 코드를 저장할때마다 ESLint의 자동수정(eslint --fix와 같은) 커맨드를 실행하도록 설정해두는게 좋다. 나는 VS Code를 사용하고, VS Code에서 파일을 저장할 때마다 자동수정을 실행하기 위해서는 VS Code의 설정파일인 settings.json에 다음과 같은 내용을 작성하면 된다. 1234567891011121314151617/* settings.json (vscode 세팅파일) */{ &quot;eslint.autoFixOnSave&quot;: true, // 위 설정 값은 deprecate 되었다, 대신 editor.codeActionsOnSave를 사용하자. &quot;editor.codeActionsOnSave&quot;: { &quot;source.fixAll.eslint&quot;: true }, &quot;eslint.validate&quot;: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, { &quot;language&quot;: &quot;typescript&quot;, &quot;autoFix&quot;: true }, { &quot;language&quot;: &quot;typescriptreact&quot;, &quot;autoFix&quot;: true }, // 역자 주: autoFix 설정을 true로 세팅한다면 다음과 같이 일반적인 문자열로 작성해도 된다. &quot;typescript&quot;, &quot;typescriptreact&quot; ]} 만약 editor.formatOnSave 옵션도 true로 설정했다면, 자바스크립트 또는 타입스크립트 파일을 저장할 때 포매팅이 두번 실행되지 않도록 다음과 같은 설정을 추가해야한다. 12345678910111213141516/* settings.json (vscode 세팅파일) */{ &quot;editor.formatOnSave&quot;: true, &quot;[javascript]&quot;: { &quot;editor.formatOnSave&quot;: false }, &quot;[javascriptreact]&quot;: { &quot;editor.formatOnSave&quot;: false }, &quot;[typescript]&quot;: { &quot;editor.formatOnSave&quot;: false }, &quot;[typescriptreact]&quot;: { &quot;editor.formatOnSave&quot;: false }} 커맨드라인 인터페이스(CLI)로 ESLint 실행하기프로젝트의 모든 코드가 컴파일러 세팅이나 포매팅, 스타일 규칙에 어긋나지 않도록 확인해주는 lint 커맨드는 package.json의 scripts 에 추가해두면 매우 유용하다. 123456/* package.json */{ &quot;scripts&quot;: { &quot;lint&quot;: &quot;tsc --noEmit &amp;&amp; eslint '*/**/*.{js,ts,tsx}' --quiet --fix&quot; }} 위 스크립트는 커맨드라인에서 npm run lint 또는 yarn lint를 입력하면 실행된다. 이 커맨드는 먼저 타입스크립트 컴파일러를 실행하고, 타입스크립트 에러가 있으면 보고한다. 만약 에러가 없다면 그다음 모든 .js, .ts, .tsx 파일에 대해 ESLint를 실행한다. 자동수정으로 수정될 수 있는 에러들은 수정되고 남은 에러가 있다면 터미널 창에 출력된다. 타입스크립트 CLI 옵션 ESLint CLI 옵션 ESLint 에러와 포매팅 에러가 커밋되지 않게 방지하기깃에 커밋되는 모든 코드를 타입스크립트, 린트, 포매팅 에러로부터 자유롭게 하고싶다면, lint-staged 라는 도구를 사용하면 된다. lint-staged는 커밋되기 위해 스테이지 된 파일들에 대해 린트를 할 수 있게 해준다. lint-staged를 husky와 함께 사용하면, 커밋이 실행되기 직전에 스테이지된 파일들을 대상으로 lint-staged에 명시된 린트 작업을 수행하도록 할 수 있다.(git hooks가 낯설다면 이 글을 읽어보자.) 역자 주: 본문에서는 lint-staged와 husky를 설치하는 과정이 나와있지 않은데 앞서 살펴 본 두 도구와 마찬가지로 yarn add -D lint-staged husky 커맨드로 설치할 수 있다. lint-stage와 husky를 설정하기 위해서는 다음과 같은 내용을 package.json에 추가하면 된다. 1234567891011/* package.json */{ &quot;husky&quot;: { &quot;hooks&quot;: { &quot;pre-commit&quot;: &quot;lint-staged&quot; } }, &quot;lint-staged&quot;: { &quot;*.{js,ts,tsx}&quot;: [&quot;eslint --fix&quot;, &quot;git add&quot;] }} 위와 같이 설정하면 사용자가 코드를 커밋하려고 할 때 lint-staged명령이 실행된다. 그러면 lint-staged는 모든 ,js, .ts, .tsx 파일들에 대해 ESLint를 실행한다. 자동수정이 가능한 에러들은 수정되어서 커밋 될 것이다. 만약 자동수정이 불가능한 에러가 있다면, 커밋은 중단될 것이고, 해당 에러를 직접 해결해야 다시 커밋할 수 있다. 개인적으로 나는 커밋 할 때 타입스크립트 컴파일러 에러 또한 통과시키고 싶지 않기 때문에, pre-commit 훅에 타입스크립트 에러를 체크하는 명령도 추가한다. husky 설정을 다음과 같이 변경하면 된다. 12345678/* package.json */{ &quot;husky&quot;: { &quot;hooks&quot;: { &quot;pre-commit&quot;: &quot;tsc --noEmit &amp;&amp; lint-staged&quot; } }} 그런데 git hooks는 커밋할 때 --no-verify라는 flag를 달면 생략되기 때문에, lint-staged와 husky에만 의존하는 방법은 커밋된 코드를 에러로부터 지켜내기에는 역부족이다. 그러므로 CI 서버에서 타입스크립트와 린트 에러가 없는 것을 확인하는 다음과 같은 커맨드를 실행하는것을 추천한다. 1tsc --noEmit &amp;&amp; eslint '*/**/*.{js,ts,tsx}' --quiet 위 명령어에서는 eslint cli에 --fix 옵션을 넘기지 않는데, 이렇게 하면 어떤 에러든 자동으로 수정하지 않고 출력한다. 자동수정이 가능한 에러는 이미 커밋단계에서 필터링 되어있어야 하기 때문에, CI가 자동으로 코드를 수정하는 일은 일어나서는 안된다. 이렇게 ESLint와 Prettier로 타입스크립트 프로젝트를 린트하고 포매팅하는 방법을 알아보았다 😎","link":"/etc/eslint-prettier-ts/"},{"title":"번역] Virtual DOM 이해하기","text":"본 글은 virtual DOM에 관한 Ire Aderinokun 글을 번역한 것 입니다. 이해를 돕기위한 의역이 존재합니다. 나는 최근 DOM 과 shadow DOM 이 정확이 무엇이고 그들이 어떻게 다른지에 대한 글을 썼다. 요약하자면 Document Object Model은 HTML 문서에 대한 객체 기반 표현 그리고 그 객체를 조작하기 위한 인터페이스를 의미한다. Shadow DOM은 DOM의 ‘가벼운’ 버젼이라고 생각할 수 있다. 이 또한 HTML 엘리먼트에 대한 객체 기반 표현이지만 완전히 독립적인 문서는 아니다. 대신에 shadow DOM은 DOM을 더 작고 캡슐화 된 부분들로 나누어 여러 HTML 문서에 걸쳐 사용할 수 있게 해준다. 아마 ‘virtual DOM’ 이라는 이와 유사한 용어를 본 적이 있을 것이다. 사실 그 개념은 수 년간 존재해왔지만 React 프레임워크(역자 주: 리액트는 프레임워크라기 보다는 라이브러리에 가깝지만 원작자의 표현을 존중한다. 후술할 프레임워크도 같은 맥락에서 살려둔다.)에서 사용되었다는 점 때문에 유명해졌다. 이 글에서는 virtual DOM이 정확히 무엇이고, 이것이 기존의 DOM과 어떻게 다르며, 어떻게 사용되는지에 대해 알아볼 것이다. 왜 virtual DOM이 필요한가?virtual DOM이라는 개념이 왜 떠오르고 있는지 이해하기 위해서 먼저 기존의 DOM을 다시 살펴보자. 앞서 언급한대로, DOM은 두 부분으로 구성된다 - HTML 문서에 대한 객체 기반 표현 그리고 이 객체를 조작하기 위한 API. 예를 들어 &lt;ul&gt;과 &lt;li&gt;로 이루어진 간단한 HTML 문서를 살펴보자. 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;list__item&quot;&gt;List item&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 이 문서는 다음의 DOM tree로 표현될 수 있다. 첫번째 &lt;li&gt;의 내용을 &quot;List item one&quot;으로 수정하고 &lt;li&gt;를 하나 더 추가하고 싶다고 생각해보자. 우선 DOM API를 이용해 우리가 업데이트 하고 싶은 엘리먼트를 찾는다. 그리고 추가 할 새로운 엘리먼트를 만들고, 여기에 속성과 내용을 부여한다. 이 모든 작업이 끝나고서야 마침내 우리는 DOM 엘리먼트들을 업데이트 할 수 있다. 12345678const listItemOne = document.getElementsByClassName('list__item')[0]listItemOne.textContent = 'List item one'const list = document.getElementsByClassName('list')[0]const listItemTwo = document.createElement('li')listItemTwo.classList.add('list__item')listItemTwo.textContent = 'List item two'list.appendChild(listItemTwo) DOM은 그러라고 만든게 아닌데…1998년, (DOM 에 대한 첫 번째 명세)[https://www.w3.org/TR/REC-DOM-Level-1/]가 처음 배포되었을 때 까지만 하더라도, 우리는 웹 페이지들을 굉장히 다르게 제작하고 운영했다. 오늘날에 비해 DOM API를 사용해 페이지의내용을 수정해야하는 경우가 훨씬 적었다. document.getElementByClassName() 같은 간단한 메소드들은 작은 스케일에서 사용해도 괜찮다. 하지만 만약 우리가 매 초마다 여러 엘리먼트를 업데이트 해야한다면, 지속적으로 DOM에 요청을 보내고 업데이트 하는 비용은 점점 비싸지기 시작한다. 심지어 DOM API의 특성 상, 특정 요소 하나만 찾아내서 업데이트 하는 작업 보다, 많은 부분을 업데이트하는 비싼 작업이 더 간단하다. 우리의 리스트 예제를 다시 보면, 리스트 전체를 새 것으로 바꿔치기 하는게, 특정 엘리먼트 하나만 업데이트 하는 것보다 쉽다. 12345const list = document.getElementsByClassName('list')[0]list.innerHTML = `&lt;li class=&quot;list__item&quot;&gt;List item one&lt;/li&gt;&lt;li class=&quot;list__item&quot;&gt;List item two&lt;/li&gt;` 이 예제에서만 보면, 두 메소드의 성능 차이는 아마도 크지 않을 것이다. 하지만 웹페이지의 크기가 커짐에 따라, 필요한 엘리먼트만 선택하고 업데이트 하는 것이 더 중요해질 것이다. virtual DOM은 그러라고 만든게 맞다!virtual DOM은 이렇게 DOM을 빈번하게 업데이트 해야하는 문제를 해결하기 위해 만들어졌다. DOM이나 shadow DOM과 달리 virtual DOM은 공식적인 스펙은 아니고, DOM과 인터페이스 하기 위한 새로운 메소드 정도로 볼 수 있다. virtual DOM은 기존 DOM의 복사본이라고 볼 수 있는데, 이 복사본은 DOM API들을 사용하지 않고도 주기적으로 조작되고 업데이트 될 수 있다. virtual DOM에 모든 변경사항이 반영되면 우리는 원본 DOM에 정확히 어떤 변화가 필요한 지 알 수 있고 필요한 변화만 최적화 해서 반영할 수 있다. virtual DOM은 어떻게 생겼을까?사실 virtual DOM이라는 이름 때문에 그 개념이 더 어렵게 느껴지곤 한다. 사실 virtual DOM은 평범한 자바스크립트 객체이다. 우리가 만든 DOM tree를 다시 한번 보자. 이 트리는 다음과 같은 자바스크립트 객체로 표현될 수 있다. 12345678910111213141516171819202122const vdom = { tagName: 'html', children: [ { tagName: 'head' }, { tagName: 'body', children: [ { tagName: 'ul', attributes: { class: 'list' }, children: [ { tagName: 'li', attributes: { class: 'list__item' }, textContent: 'List item', }, // end li ], }, // end ul ], }, // end body ],} // end html 이 객체를 virtual DOM이라고 생각하면 된다. 원본 DOM과 마찬가지로, 이는 HTML 문서에 대한 객체기반 표현이다. 하지만 동시에 자바스크립트 객체이므로 언제나 자유롭게 이를 수정할 수 있고, 꼭 필요한 경우가 아니라면 실제 DOM은 전혀 건드릴 필요가 없다. 매번 전체 객체를 다 사용하기 보다는, 보통은 virtual DOM의 작은 섹션을 따로 나누어서 사용한다. 예를 들어 우리는 아까 만든 &lt;ul&gt; 엘리먼트와 대응되는 list 컴포넌트에서 작업을 수행할 수 있다. 1234567891011const list = { tagName: 'ul', attributes: { class: 'list' }, children: [ { tagName: 'li', attributes: { class: 'list__item' }, textContent: 'List item', }, ],} virtual DOM의 내부를 살펴보자우린 virtual DOM이 어디에 사용되는지 살펴보았는데, virtual DOM은 어떻게 이런 문제를 해결하는 것일까? 앞서 언급한 대로, virtual DOM을 사용하면 우리는 DOM에서 변화가 생긴 부분만 콕 집어서 업데이트 할 수 있다. 다시 우리의 예제로 돌아가서 DOM API로 했던 것과 같은 변화를 만들어 보자. 가장 먼저 할 일은 우리의 변경사항이 반영된 virtual DOM의 복사본을 만드는 것이다. 우리는 DOM API를 쓸 필요가 없다. 그냥 객체만 만들면 된다. 12345678910111213141516const copy = { tagName: 'ul', attributes: { class: 'list' }, children: [ { tagName: 'li', attributes: { class: 'list__item' }, textContent: 'List item one', }, { tagName: 'li', attributes: { class: 'list__item' }, textContent: 'List item two', }, ],} 이 copy는 diff라는 것을 만드는것에 사용되는데 이 경우에는 list 그리고 업데이트 된 항목을 나타낸다. diff는 다음과 같이 생겼다. 1234567891011const diffs = [ { newNode: { /* new version of list item one */ }, oldNode: { /* original version of list item one */ }, index: /* index of element in parent's list of child nodes */ }, { newNode: { /* list item two */ }, index: { /* */ } }] 이 diff는 실제 DOM 을 어떻게 업데이트 할 것인지 알려준다. 모든 diff들이 다 수집되고 나면, 그때 실제 DOM에게 변화를 발생시긴다. 이때 오직 변화가 필요한 부분만 업데이트된다. 예를 들어 우리는 각각의 diff를 순회하면서 새로운 자식 노드를 추가하거나, 기존의 노드를 업데이트 할 수 있다. 1234567891011121314const domElement = document.getElementsByClassName('list')[0]diffs.forEach(diff =&gt; { const newElement = document.createElement(diff.newNode.tagName) /* Add attributes ... */ if (diff.oldNode) { // If there is an old version, replace it with the new version domElement.replaceChild(diff.newNode, diff.index) } else { // If no old version exists, create a new node domElement.appendChild(diff.newNode) }}) 이건 실제 virtual DOM의 동작을 아주 간단히 설명한 것이라는 것을 명심하길 바란다. 여기서 다루지 않은 경우의 수도 많이 존재한다. virtul DOM 과 프레임워크우리의 예시처럼 직접 virtual DOM을 다루는 것 보다는, 프레임워크를 통해 다루는 것이 훨씬 보편적이다. React나 Vue같은 프레임워크들은 DOM업데이트를 더 효율적으로 수행하기 위해 virtual DOM 개념을 사용한다. 예를 들어 우리의 list 컴포넌트를 React로 작성하면 다음과 같다. 12345678910import React from 'react'import ReactDOM from 'react-dom'const list = React.createElement( 'ul', { className: 'list' }, React.createElement('li', { className: 'list__item' }, 'List item'))ReactDOM.render(list, document.body) list를 업데이트 하고싶다면, 그냥 템플릿 전체를 다시 써버리고 다시 한번 ReactDOM.render()를 호출하면 된다. 123456const newList = React.createElement(&quot;ul&quot;, { className: &quot;list&quot; }, React.createElement(&quot;li&quot;, { className: &quot;list__item&quot; }, &quot;List item one&quot;), React.createElement(&quot;li&quot;, { className: &quot;list__item&quot; }, &quot;List item two&quot;););setTimeout(() =&gt; ReactDOM.render(newList, document.body), 5000); React는 virtual DOM을 사용하기 때문에, 전체 템플릿을 렌더링해도, 실제로는 변경된 부분만 업데이트 한다.개발자 도구를 연 채로 변화를 확인하면 특정 엘리먼트만 변화한다는 것을 확인할 수 있다. DOM vs virtual DOM요약하자면, virtual DOM은 DOM엘리먼트를 좀 더 쉽고 효율적인 방식으로 다룰 수 있게 해주는 도구이다. 자바스크립트 객체로 표현된 DOM이고, 우리가 언제든지 필요하다면 수정할 수 있다. virtual DOM에 만들어진 변화들은 실제 DOM과 대조되고, 실제 DOM에 덜 빈번하게 반영된다.","link":"/frontend/virtual-dom/"},{"title":"GatsbyJS와 Github Pages로 블로그 만들기","text":"여느 개발자들 처럼 나도 블로그를 운영하고 싶다는 생각은 오랫동안 해왔다. 하지만 내가 원하는 수준의 커스터마이징이나, 마크다운 에디터를 제공하는 기존의 플랫폼이 존재하지 않는 상황에서 블로그를 운영하기위해서는 많은 노력이 필요했다. 수 많은 도전과 실패 끝에 나는 GatsbyJS와 Github Pages를 이용하는 방법에 정착했고, 그간의 과정을 통해 배운것을 공유하며 첫 포스팅을 장식해보고자 한다. Github Pages ?Github Pages 는 Github 에서 제공하는 정적 웹사이트 호스팅 서비스이다. 다시 말해 html, js, css 파일들로 구성된 정적인 파일들을 배포해주는 서비스이다. 사용법도 아주 간단하다 Github 저장소를 생성하고, 저장소 설정에서 호스팅 할 정적 웹사이트의 리소스 위치를 지정해주면 된다. 우선 “username”.gtihub.io 의 형식으로 이름을 짓고 저장소를 만든다. 저장소 설정에서 배포할 리소스의 위치를 지정해줄 수 있는데, 선택지는 두 가지이다. master 브랜치의 루트 디렉토리 혹은 그 아래의 docs 폴더 내부이다. 아마도 프레임워크나 라이브러리들이 프로젝트의 파일 구조를 깔끔하게 유지하면서 문서화 할 수 있도록 배려해준 듯 하다. 나는 master 브랜치에 배포를 선택했다. 이제 Github Pages를 통한 배포 준비는 끝났다고 볼 수 있다. 지정한 위치에 파일을 업로드하면 Github Pages 에서 리소스를 찾아내 배포해주는데 index.html 이나 Readme.md 파일을 엔트리 포인트로 삼기 때문에,해당 이름을 가진 파일이 존재해야 한다. 하지만! 이는 그저 html 파일들의 연결에 불과하다. 우리는 좀 더 멋지고 힙한 블로그를 원한다. 이를 위한 도구가 바로 GatsbyJS 이다. GatsbyJS !우리가 원하는 힙하고 멋진 블로그들은 그리 단순하지 않다. React 혹은 Vue 같은 프론트엔드 라이브러리를 사용할 수도 있고, 포스트를 저장하려면 데이터를 저장할 서버도 필요할 것이다. 하지만 Github Pages 는이런 복잡한 웹사이트를 배포할 수 없고, 설사 가능하더라도 이를 구현하려면 너무 많은 노력과 자원이 필요하다. 이러한 문제를 해결해 주는 것이 GatsbyJS 이다. GatsbyJS 는 우리가 원하는 복잡한 웹사이트를 Github Pages 가 배포할 수 있는 정적 웹사이트의 형태로 만들어준다. 덕분에 우리는 React와 GraphQL을 기반으로만든 복잡하고도 멋진 블로그를 Github Pages 를 통해 배포할 수 있다. 심지어 초심자를 위한 스타터 템플릿도 많이 공유되고 있다. 바로 시작해보자. 우선 gatsby-cli를 설치하자. 1npm install -g gatsby-cli 그리고 개츠비 프로젝트를 시작하자 1gatsby new &quot;porject_name&quot; &quot;starter_url&quot; 뒤의 &quot;starter_url&quot; 부분에 스타터 템플릿의 url을 추가하면 꽤 많은 부분이 완성된 프로젝트로 시작할 수 있다. 현재 이 블로그도 이미 만들어 진 스타터를 선택해 프로젝트를 시작했다. 12cd &quot;project_name&quot;git remote add origin https://github.com/&quot;username&quot;/&quot;username&quot;.github.io 이제 GatsbyJS 폴더에 들어가서 배포하려는 저장소를 원격 저장소로 추가한다. 이때 우리의 배포 리소스 위치를 생각해보자. master 브랜치의 루트디렉토리이다. 즉 저장소의 최상위 경로에 index.html 을 포함하는 정적 웹사이트 파일이 존재해야 한다는 것이다. 하지만 현재의 프로젝트는 정적 웹사이트를 만들어내는 프로젝트이다. 이를 배포하기위해 build 명령어를 사용하면 public이라는 경로에 정적 웹사이트 파일들이 생성된다. 123456&quot;project_name&quot;/|-- # some|-- # files|-- # of|-- # GatsbyJS|-- public 그렇다면 어떻게 public 폴더 내부의 파일을 배포할까? gh-pages 패키지와 추가적인 브랜치를 활용할 수 있다. 현재의 파일들 즉 정적 웹사이트 생성을 위한 파일들은 다른 브랜치로 옮기고, 생성된 정적 웹사이트 파일들만 master 브랜치에 저장하고 배포하자. 123git branch -m dev # dev 브랜치를 만들고 현재의 파일들을 # 해당 브랜치로 이동하고 기본 브랜치로 설정한다.npm install gh-pages --save-dev 현재의 파일들을 다른 브랜치로 옮기고 패키지를 설치한다. 그리고 배포를 위한 스크립트를 작성하자. 1234567# package.json.... &quot;scripts&quot;: { .... &quot;deploy&quot;: &quot;gatsby build &amp;&amp; gh-pages -d public -b master&quot; },.... 설정은 끝났다. npm run deploy 명령어를 실행하면 dev 브랜치에서 정적 웹사이트를 생성하고 해당 폴더를 master 브랜치에 푸시해 배포가 시작된다. 이렇게 GatsbyJS 와 Github Pages 를 사용한 블로그가 만들어졌다. 이제 포스팅만 하면 된다! 👏👏👏 참고 GatsbyJS Gatsby 로 Blog 만들기 Gasby로 github 블로그(github page) 구축하기","link":"/log/gatsby-github-pages/"},{"title":"codepush로 react-native 앱 심사 없이 업데이트 하기","text":"codepush란?codepush는 react native 혹은 cordova 로 개발한 앱을 번거로운 심사과정 없이 바로 업데이트 할 수 있도록 해주는 서비스입니다. 네이티브 코드라는 막으로 감싸져있는 내부의 코드 번들을 원격 저장소에 업로드 해두고, 로컬 디바이스의 앱 번들과 비교해 차이가 있으면 다시 다운로드 받아 업데이트 하는 형태인 듯 합니다. 현재 ios (7+), android (4.1+), windows등의 운영체제를 지원하고 있고, react native 기준으로 Image, Maview.Marker, PrgoressViewIOS 등 특정 컴포넌트들은 소스가 되는 이미지를 codepush 서비스로 업데이트 할 수 있고 또 SliderIOS나 Video등 일부는 불가능하다고 하는 걸 보면 앱의 모든 부분을 완전히 업데이트 하는 것은 불가능한 듯 합니다. 허나 4달 정도 직접 사용해 본 결과 자바스크립트 번들을 통째로 업데이트 할 수 있기 때문에 네이티브 코드를 추가로 작성한다거나 하는 부분이 아니면 업데이트에서 제한을 거의 느낄 수 없었습니다. 세팅하기AppCenter CLI 설치하기12345yarn global add appcenter-cliornpm i -g appcenter-cli Appcenter에 앱과 배포트랙 등록하기우선 appcenter-cli로 로그인을 합니다. 1appcenter login # 웹 브라우저가 켜지면 앱센터에 로그인해서 키를 복사한 후 커맨드라인에 붙여넣으면 됩니다. 이제 appcenter에 내 앱을 생성하고, 배포트랙을 설정해야합니다. 직접 appcentr 대시보드에 접속해서 진행해도 되지만, cli로는 명령어 한줄로 해결할 수 있으니 활용해봅시다. 12# appname 과 os 부분을 본인 프로젝트에 맞게 수정해주셔야 합니다.appcenter apps create -d {appname} -o {os}(Android/iOS) -p React-Native 실제 프로젝트에서 사용할 떄는 appname-ios, appname-android로 앱 두개를 등록하고 관리하는 형태로 사용하고 있습니다. 이제 각 앱마다 배포트랙을 생성해줍시다. 12345# 배포트랙은 말 그대로 배포를 하는 트랙입니다.# 여러개로 설정해서 관리하는 경우도 있다고 하는데 아직 그렇게 깊게 경험해보지는 못했습니다.# 만약 appcenter 대시보드를 이용하면 기본적으로 Staging 그리고 Production 트랙이 생성됩니다.# 마지막에 살펴볼 배포과정에서 트랙 이름을 생략하면 Staging으로 배포를 시도합니다.appcenter codepush deployment add -a {username/appname} {trackname} 이때 터미널에 배포 키가 보여집니다. 나중에 설정에 사용해야하니 복사해둡시다. 혹시나 놓쳤다면 다음 명령어로 다시 확인할 수 있습니다. 1appcenter codepush deployment list -a {username/appname} -k 프로젝트에 codepush 설치하기react native 프로젝트에 codepush 디펜던시를 추가합니다. 1yarn add react-native-code-push iOS Setup 디펜던시 설치 react native 프로젝트 루트 디렉토리 기준으로 다음 명령어로 네이티브 디펜던시 설치를 진행합니다. 1cd ios &amp;&amp; pod install &amp;&amp; cd .. AppDelegate.m 수정 123456#import &quot;AppDelegate.h&quot;#import &lt;CodePush/CodePush.h&gt; // codepush 헤더 추가#import &lt;React/RCTBridge.h&gt;... source URL 수정하기 12return [[NSBundle mainBundle] URLForResource:@&quot;main&quot; withExtension:@&quot;jsbundle&quot;]; &lt;!-- turn this into next line --&gt;return [CodePush bundleURL]; 이때 bundleURL은 앱의 JSBundle이 main.jsbundle이라는 이름을 가지는 것을 기준으로 하기 때문에, 만약 번들 이름이 어떤 이유로 변경되어있다면 bundleURLForResource: 혹은 bundleURLForResource:withExtension:등을 호출해야 합니다. 특별한 경우가 아니라면 sourceURLForBridge 메소드는 다음과 같은 형태로 작성됩니다. 12345678- (NSURL *)sourceURLForBridge:(RCTBridge *)bridge{ #if DEBUG return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@&quot;index&quot; fallbackResource:nil]; #else return [CodePush bundleURL]; #endif} Info.plist에 배포 키 추가하기. codepush 원격 저장소의 어떤앱에 접근할지 알려주기 위해 Info.plist에 아까 확인했던 codepush 배포키를 CodePushDeploymentKey 키의 값으로 추가해주어야 합니다. 이 키는 code-push deployment ls &lt;appName&gt; -k 명령어로 다시 확인할 수 있습니다. 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; ... &lt;key&gt;CodePushDeploymentKey&lt;/key&gt; &lt;string&gt;mydeploymentkey&lt;/string&gt; ...&lt;/plist&gt; HTTP 예외 도메인 설정 (iOS) 사실 이부분이 좀 애매했습니다. 공식문서를 읽어보고 찾아서 이해해야하는데 일단 지금 작업중인 프로젝트에서는 다음과 같은 상태이고 문제 없이 사용하고있습니다. 123456789101112131415161718192021222324252627&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; ... &lt;key&gt;CodePushDeploymentKey&lt;/key&gt; &lt;string&gt;mydeploymentkey&lt;/string&gt; ... &lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSExceptionDomains&lt;/key&gt; &lt;dict&gt; &lt;key&gt;codepush.appcenter.ms&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;key&gt;localhost&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSExceptionAllowsInsecureHTTPLoads&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/dict&gt; ... &lt;/dict&gt;&lt;/plist&gt; Android 셋업 android/app/build.gradle에 codepush.gradle를 추가합니다. 1234...apply from: &quot;../../node_modules/react-native/react.gradle&quot;apply from: &quot;../../node_modules/react-native-code-push/android/codepush.gradle&quot;... MainApplication.java를 업데이트합니다. 12345678910111213...// 1. codepush 패키지를 import 합니다.import com.microsoft.codepush.react.CodePush;public class MainApplication extends Application implements ReactApplication { private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) { ... // 2. getJSBundleFile method 를 오버라이드 합니다. @Override protected String getJSBundleFile() { return CodePush.getJSBundleFile(); } };} 배포키를 strings.xml에 추가합니다. 아까 확인했던 그 배포키입니다. 1234&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;AppName&lt;/string&gt; &lt;string moduleConfig=&quot;true&quot; name=&quot;CodePushDeploymentKey&quot;&gt;mydeploymentkey&lt;/string&gt;&lt;/resources&gt; 실제로 프로젝트에 codepush 적용하기codepush 세팅이 끝났으니, 실제로 내 앱이 자바스크립트 번들을 원격 저장소에서 받아와서 업데이트 할 수 있도록 코드를 작성해야 합니다. 여러가지 옵션을 설정할 수 있지만 우선 가장 간단한 형태만 알아보겠습니다. 123456789101112131415161718// 최상위 컴포넌트라고 가정합니다.import React from 'react'import codePush from 'react-native-code-push'const App = () =&gt; ( &lt;AwesomeWrapper&gt; &lt;AwesomeContent /&gt; &lt;/AwesomeWrapper&gt;)// 각종 codepush 관련 옵션을 설정하고const codePushOptions = { checkFrequency: codePush.CheckFrequency.ON_APP_START, installMode: codePush.InstallMode.IMMEDIATE,}// 최상위 컴포넌트를 codepush 래퍼로 감싸서 export 시키고, 해당 컴포넌트를 앱에 등록시킵니다.export default codepush(codePushOptions)(App) 위의 예제는 버젼 체크를 하는 케이스와 업데이트 하는 형태를 고정해두는 형태이지만, codepush.sync 함수로 동적으로 트리거 할수도 있습니다. 자세한 내용은 codepush api에서 확인할 수 있습니다. 배포하기앱이 세팅되고, appcenter 로그인이 된 상태에서 다음 명령어로 배포할 수 있습니다. 당연한 얘기일 수 있으나, react native 프로젝트 루트 디렉토리에서 진행해야 package.json을 제대로 읽어서 배포를 수행할 수 있습니다. 1appcenter codepush release-react -a {username/appname} -d {trackname}","link":"/mobile/react-native-codepush/"},{"title":"Redux로 React 앱 상태관리 하기","text":"리덕스를 이용한 리액트 앱 상태관리를 TIL 저장소에 간단히 정리하려다가 신이나서 그림까지 그려버렸다. 그런 김에 좀 다듬어서 포스팅 하기로 했다. React의 문제 - 상태관리리액트는 결국 데이터 변화에 따른 렌더링을 관리하기 위한 라이브러리이다. 그래서 이 데이터의 변화 또는 데이터 자체를 잘 관리하는 것이 중요한 작업인데, 그렇게 쉽지만은 않다. UI의 각 부분을 컴포넌트라는 독립적인 부분으로 나누어서 구현하는데, 이때 어떤 데이터를 어떤 컴포넌트의 state로 관리할지를 정하는 것이 어렵기 때문이다. 편의를 위해 최상위 컴포넌트에서 모든 데이터를 관리할 수도 있지만 그렇게 되면 실제로 데이터를 다룰 컴포넌트에게 데이터를 전달하는 과정이 번거로워질 수 있다. 상태관리 도구, Redux이러한 state, 즉 상태관리의 문제를 해결하기 위한 도구가 바로 리덕스이다. 사실 이는 리액트를 위해 만들어진 도구는 아니고, 그냥 상태관리를 위한 JS 라이브러리이다. 그래서 실제로 리액트 앱에서 사용하는 코드를 보면 react-redux라는 추가적인 패키지를 사용해 둘을 연결해주어야한다. 하지만 이건 나중에 보고 우선 큰 그림을 보자. 간단히 설명하자면 store 라는 상태관리를 위한 전역적인 컨테이너를 생성해서 사용하는 것이다. 리덕스를 어떻게 사용할 수 있는지 알아보자. Redux 기본 개념그렇다면 store를 이용한 상태관리는 어떻게 이루어질까? 위의 그림은 store와 컴포넌트의 상호작용을 간략하게 표현한 것이다. store 는 우리가 관리하려는 데이터인 state 와 reducer 라는 것을 가지고있다. 데이터를 수정하고자 할 때 컴포넌트는 action 을 dispatch 하고, 필요한 데이터를 가져올 수 있다. 갑자기 새로운 용어들이 마구 쏟아져나왔다. 이들은 리덕스 패턴을 구성하는 요소들이다. 좀 더 자세히 알아보자. store (상태 저장소)말 그대로 상태를 저장하는 곳이다. store는 두 가지 요소로 구성된다. 우리가 다룰 데이터의 현재 상태인 state와 데이터를 변경하기 위한 인터페이스인 reducer가 그것이다. 간략하게 나타내면 아래와 같은 형태이다. 12345678910const store = { &quot;State&quot;:{ &quot;session&quot;: data, &quot;other&quot;: things }, &quot;Reducer&quot;:{ &quot;sessionReducer&quot;: func to change session data, &quot;otherReducer&quot;: func to change other data }} Reducer에 대해서는 별도의 항목에서 더 자세히 설명하겠다. dispatch (state 수정 인터페이스)상태를 변경하려고 할 때에는 store에게 어떤 데이터를 어떻게 변경할 지 알려줘야한다. 이 때 이런 내용을 전달하기 위한 인터페이스가 바로 dispatch이다. 인자로 내가 어떤 변경을 할 것 인지에 대한 정보를 담아서 호출하면 이것이 store에게 전달된다. action (store에 전달할 메시지)이부분과 reducer가 가장 이해하기 어려웠 던 것 같다. 쉽게 말하면 ‘내가 하려는 어떤 행동’ 이라고 생각하면 된다. 아케이드 게임기를 생각해보자. 펀치, 킥, 점프 등의 버튼이 있고 유저는 어떤 동작을 취하기 위해서 버튼을 누를 것이다. 이때 내가 취하려는 동작인 펀치, 킥, 점프 등이 action이다. reducer (action 해석기)위의 사진에서 볼 수 있듯이 컴포넌트가 action을 dispatch하면 이는 먼저 reducer를 거치고 state로 넘어가게 된다. reducer가 컴포넌트로부터의 메시지를 받아서 해석하고 state에 적절한 작업을 반영하는 것이다. 내가 점프 버튼을 누르면 게임 속 캐릭터는 이를 이해하고 뛰어오르는데, 이를 가능하게 하는 것이 reducer이다. Redux로 React 앱 상태관리 하기아케이드 게임기를 예로 들어 리덕스의 작업 흐름을 이해해보자. 위 그림에서 각 버튼은 왼쪽, 가운데, 오른쪽으로 구슬을 발사하고, 필살기로 폭탄을 사용한다, 화면 아래쪽의 캐릭터는 사용자 입력에 따라 대포의 방향을 바꾸거나 구슬 대신 폭탄을 발사해준다. 발사된 구슬은 궤도대로 날아가 다른 구슬들 옆에 붙거나 터지고 폭탄이 날아가 많은 구슬을 터트리기도 한다. 리덕스 패턴도 이와 같이 동작하는데, 실제로 이를 구현하는 규칙이 절대적으로 정해져 있지는 않고 몇가지 패턴들만 존재한다. 우선은 공식 문서의 형태를 따르기로 하자. 앞서 살펴본 리덕스의 구성 요소 중 우리가 직접 만들어야 하는 것은 action 과 reducer 이다. action 만들기아케이드 게임의 비유를 떠올려보자. 여기서 우리에게 만들고자 하는 동작은 왼쪽, 가운데, 오른쪽으로 대포를 발사해 해당 방향에 구슬을 붙이는 것, 그리고 폭탄을 발사하는 것이다. 이를 구현하는 코드를 보자. 1234567891011121314151617181920212223242526272829/* actions.js *//* * action types */export const LEFT = 'SHOT_LEFT'export const CENTER = 'SHOT_CENTER'export const RIGHT = 'SHOT_RIGHT'export const BOMB = 'SHOT_BOMB'/* * action creators */export function L() { return { type: LEFT }}export function C() { return { type: CENTER }}export function R() { return { type: RIGHT }}export function B(bomb) { return { type: BOMB, bomb: bomb }} 우리가 구현할 것은 action 한 가지 라고 했는데 코드에서는 두 가지로 나뉘어졌다. 이는 나중에 프로젝트 규모가 커지는 경우 그리고 각 액션에 인자로 넘길 데이터가 생길 경우 등을 고려해 단계를 나누어 둔 것이다. action type은 우리가 하고자 하는 행동을 나타낸다. 위의 예시에서는 각 방향으로 구슬 쏘기와 폭탄 발사하기가 된다. action creator는 각 행동에 대해 특정 형태의 객체를 아웃풋으로 내는 함수인데, 추가적으로 필요한 인자도 여기서 처리해준다. 쉽게 말하자면 우리가 하고자 하는 행동을 store에게 reducer가 해석할 수 있는 정형화 된 형태로 만들어주는 것 이다. 이는 아케이드 게임에서 버튼의 역할과 비슷하다고 볼 수 있다. 왼쪽으로 구슬을 쏘겠다는 우리의 의사를 전기적 신호로 만들어 주는것이 바로 action creator이고, 이 결과로 만들어지는 전기 신호, 객체가 바로 action이다. 다시말해 action 을 만들기 위해서는, 데이터에 가할 조작의 종류인 action type을 지정하고 이러한 action을 store가 받아들일 수 있는 (엄밀히 말하면 reducer가 해석할 수 있는) 형태로 만들어주는 action creator를 만들어주면 된다. reducer 만들기이제는 우리의 action을 해석해서 state에 적절한 작업을 취해 줄 reducer를 만들어야 한다. reducer는 우리가 L 버튼을 누르면 대포를 왼쪽으로 돌리고 발사해야한다. 이를 코드로 구현해보자. 1234567891011121314151617181920212223242526272829/* reducers.js */import { combineReducers } from 'redux'import { LEFT, CENTER, RIGHT, BOMB } from './actions'function bubbles (state = &quot;initial state&quot;, action){ switch(action.type){ case LEFT: return newStateAfterAction case CENTER: return newStateAfterAction ... default: return state }}function otherState (state = &quot;other initial state&quot;, action){ switch(action.type){ ... }}const reducer = combineReducers({ bubbles, otherState})export default reducer 좀 복잡해보인다. 하나하나 천천히 뜯어봐야겠다. bubbles는 구슬의 상태 정보를 다루는 reducer이다. 우선 현재의 상태 정보인 state를 인자로 받고, 만약 입력이 없다면 초기값을 할당해준다. 그리고 우리가 만든 action creator가 반환하는 객체인 action도 인자로 받는다. 내부에서는 action type에 따라서 변화가 반영된 새로운 state 값을 반환한다. 여기서 주의할 점은 기존의 state 값을 변경하는 것이 아니라, 새로운 값을 리턴해야한다는 것이다. 이는 redux를 사용하며 지켜야하는 원칙이다. 따라서 Spread Operator가 자주 사용되고는 한다. 그 다음 함수는 우리가 상태를 관리할 또 다른 데이터에 관한 reducer 인데, 이는 우리의 비유가 아닌 실제 앱을 위한 예시이다. 실제 프로젝트에서 우리가 다루는 상태(state)는 꽤 복잡하고 크다. 즉 다양한 데이터를 다룬다는 것이다. 각 데이터 마다 수행할 작업(action)이 다르기 때문에 reducer는 데이터 마다 하나씩 만들어야한다. 현재 우리 앱의 state를 보면 아래와 같은 상태일 것이다. 1234const state = { bubbles: ~~~, otherState: ~~~} 이제 우리가 만든 개별 리듀서들이 state의 각 값들을 핸들링 할 수 있게 매칭해주어야 한다. 이를 코드로 보면 다음과 같을 것이다. 123456function reducer(state = {}, action) { return { bubbles: bubbles(state.bubbles, action), otherState: otherState(state.otherState, action), }} 실제 앱에서 많은 데이터들을 다루는 많은 리듀서들을 이렇게 하나하나 합치는 작업을 편하게 해주기 위한 함수가 바로 combineReducer이다. 아래의 코드는 위의 코드와 동일하다. 1234const reducer = combineReducers({ bubbles, otherState,}) 드디어 action과 reducer를 다 만들었다. 이제 store를 생성하고 사용하기만 하면 된다. store 생성하고 상태관리 하기이제 실제 리액트 앱에서 리덕스를 이용해 상태관리를 해보자. 리덕스의 store는 모든 컴포넌트가 공유하는 전역적인 상태 컨테이너라고 했다. 그렇기 때문에 최상위 컴포넌트를 렌더링하는 곳에서 store를 선언하고 하위 컴포넌트들에게 전달 해주어야 한다. 아래 코드는 CRA로 만들어진 리액트 앱에서 store를 생성하고 하위 컴포넌트로 전달하는 예시이다. 12345678910111213141516/* index.js */import React from 'react'import ReactDOM from 'react-dom'import App from './App'import reducer from './reducers'import { createStore } from 'redux'import { Provider } from 'react-redux'const store = createStore(reducer)ReactDOM.render( &lt;Provider store={store}&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById('root')) 우선 최상위 컴포넌트인 &lt;App /&gt;을 DOM에 렌더링하는 index.js에서 작업을 진행한다. 우선 redux 패키지의 createStore에 우리가 만든 reducer를 인자로 넘겨 store를 만든다. 그리고 react-redux 패키지의 Provider 컴포넌트를 활용해 해당 store를 하위 컴포넌트 모두가 접근 가능하도록 전달한다. 거의 다 왔다. 이제 실제로 컴포넌트에서 store에 접근해 state를 변경시키고 값을 읽어오는 과정을 보자. 123456789101112131415161718192021/* App.js */import React from 'react'import { useSelector, useDispatch } from 'react-redux'import { L, C, R, B } from './actions'function App() { const bubbles = useSelector(state =&gt; state.bubbles) const dispatch = useDispatch() return ( &lt;div className=&quot;App&quot;&gt; &lt;div className=&quot;Panel&quot;&gt;{bubbles}&lt;/div&gt; &lt;div className=&quot;Buttons&quot;&gt; &lt;button onClick={() =&gt; dispatch(L())}&gt;L&lt;/button&gt; &lt;button onClick={() =&gt; dispatch(R())}&gt;C&lt;/button&gt; ... &lt;/div&gt; &lt;/div&gt; )}export default App 위는 실제로 데이터를 조작하는 &lt;App /&gt; 컴포넌트다. react-redux에서 useSelector, useDispatch 를 불러와 사용한다. useSelector 함수를 사용해 state의 특정 값을 불러올 수 있다. 그리고 useDispatch 함수를 사용해 store에 dispatch 하는 함수를 지역 변수에 할당해 사용할 수 있다. 그리고 dispatch 함수를 호출하는 형태에 유의하자. 이벤트가 발동되면 dispatch 함수를 호출하는데 이때 인자로 우리가 만들었던 action creator 함수의 결과값을 넘겨준다. 이는 결국 action type과 추가적인 인자를 가진 action 객체를 dispatch 한다는 의미이다. 이렇게 리덕스를 활용한 리액트 앱 상태관리가 끝났다. 참고 Redux.js","link":"/frontend/react-redux/"},{"title":"스토리북을 이용한 컴포넌트 개발 (1) - 시작하기","text":"웹 프로젝트든 앱 프로젝트든 UI 개발을 하다보면 - 특히 프로젝트가 더 많이 진행될 수록 - 컴포넌트 하나만 따로 떼어서 이 컴포넌트가 제대로 동작하는지 확인하는 과정이 어려워 질 때가 있다. 좀 더 생산적인 UI 개발 환경을 구축하기 위해 스토리북을 사용해보자. 스토리북이란? Storybook is an open source tool for developing UI components in isolation for React, Vue, and Angular. It makes building stunning UIs organized and efficient. 스토리북은 UI 컴포넌트를 독립적인 환경에서 개발하기위한 도구이다. 사용자(개발자)는 스토리북을 이용해 컴포넌트를 어플리케이션의 다른 부분과 독립적으로 렌더링하고, 테스트해볼 수 있게 된다. 따라서 컴포넌트의 시각적인 아웃풋을 직접 확인하며 코드를 짜는 속도도 빨라질 뿐 아니라, 디자이너와 소통하는 과정도 빨라지기 때문에 생산성 향상에 큰 도움이 된다. 설치하기스토리북은 여러가지 프론트엔드 라이브러리, 프레임워크를 지원하는데, 본문에서는 CRA 기준으로 알아보겠다. 설치는 cli를 이용한 자동설치와, 직접적인 의존성 설치를 위한 수동설치로 나뉜다. Quick Startinit 명령어만 입력하면, 알아서 package.json을 읽어서 어떤 프론트엔드 라이브러리를 사용하고 있는지 확인한 후 의존성을 설치해준다. 1npx @storybook/cli sb init 만약 문제가 발생한다면 어떤 환경인지 --type 플래그로 직접 알려주는 것도 가능하다. 12npx @storybook/cli sb init --type react_scripts# CRA로 init 한 프로젝트의 경우 react_scripts 타입을 사용해준다. 설치가 완료되면 ./storybook/, ./src/.stories/ 디렉토리가 생성되고, ./storybook/main.js 에서 스토리북 관련 설정을 할 수 있다. 123456789101112/* ./storybook/main.js */module.exports = { stories: ['../src/**/*.stories.js'], // 스토리북이 읽어들일 스토리 파일들의 이름 형식을 지정한다. addons: [ '@storybook/preset-create-react-app', '@storybook/addon-actions', '@storybook/addon-links', ], // addon은 잠시후에 더 알아보자.} Slow Start직접 의존성 설치를 해줄 수 도 있다. 1yarn add -D @storybook/react 만일을 위해 react, react-dom, babel-loader, @babel/core가 설치되어있는지 확인하자. 해당 라이브러리들이 @storybook/react의 peerDependency이다. 설치가 완료되면 ./storybook/main.js 파일을 만들고 스토리북 설정을 위한 내용을 작성하자. 12345/* ./storybook/main.js */module.exports = { stories: ['../src/**/*.stories.[tj]s'],} 이제 ./src/stories/ 디렉토리에 실제 스토리를 작성하자. 스토리는 각 컴포넌트 별 테스트라고 생각하면 된다. 12345678910111213141516/* ./src/index.stories.js */import React from 'react'import { Button } from '@storybook/react/demo'export default { title: 'Button' }export const withText = () =&gt; &lt;Button&gt;Hello Button&lt;/Button&gt;export const withEmoji = () =&gt; ( &lt;Button&gt; &lt;span role=&quot;img&quot; aria-label=&quot;so cool&quot;&gt; 😀 😎 👍 💯 &lt;/span&gt; &lt;/Button&gt;) 이제 스토리북을 실행하기위한 스크립트를 추가하자. 123456789/* package.json */{ ... &quot;scripts&quot;: { ... &quot;storybook&quot;: &quot;start-storybook&quot; }} 조금 더실제 프로젝트를 진행할 때에는, 실행하기이제 스토리북 설치가 끝났다. 스크립트를 실행해보자. 1yarn storybook 로컬호스트에 스토리북 서버가 올라간 것을 확인할 수 있을 것이다. 다음글에서는 스토리북을 이용해 실제로 컴포넌트를 렌더링하고 테스트 하는 방법을 알아보자. 참고 Storybook Start Guide","link":"/frontend/storybook/first/"},{"title":"번역] 모던 리액트 테스팅, 파트 1 - 모범사례","text":"Artem Sapegin의 Modern React testing, part 1: best practices를 저작자의 허가를 받고 번역한 글입니다. 이 시리즈는 React 컴포넌트, 좀 더 보편적으로는 프론트엔드 분야에서 이루어지는 테스팅의 오늘날 모습을 심층적으로 요약한 것으로, 단순히 방법만이 아니라 이유에 관해서도 설명합니다. 왜 자동화된 테스트를 작성해야 하고, 어떤 테스트를 해야 하는지, 어떻게 테스트해야 하는지에 대해 알아볼 것이고, 더 나아가서는 Jest, Enzyme 그리고 React Testing Library를 사용해서 어떻게 리액트 컴포넌트를 하는지 알아볼 것입니다. 3년 전에도 이와 비슷한 글을 썼는데, 지금 돌아보면 아주 엉망입니다. 그 당시에 추천했던 것들의 대부분은 지금 사용하지 않습니다. 이 글은 시리즈의 첫 번째 글이고, 왜 테스트 자동화가 유용하고, 어떤 종류의 테스트를 작성해야 하며, 테스팅 베스트 프랙티스가 무엇인지 배울 것입니다. 모던 리액트 테스팅: 모범사례 (이 글) 모던 리액트 테스팅: Jest와 Enzyme (*역자 주: 곧 번역할 예정입니다.) 모던 리액트 테스팅: Jest와 React Testing Library (*역자 주: 곧 번역할 예정입니다.) 왜 테스트를 자동화하는가?자동화 테스트가 유용한 이유는 여러 가지가 있지만, 제가 가장 좋아하는 이유는 ‘우리가 이미 테스트를 하고 있다’라는 점입니다. 새로운 버튼을 하나 추가한다고 생각해봅시다. 코드를 다 작성하고 나면, 브라우저를 연 다음, 버튼이 잘 작동하는지 클릭해 볼 것입니다. 이것이 수동 테스트입니다. 이 절차를 자동화함으로써 우리는 한번 제대로 동작했던 기능이 언제나 제대로 동작할 것이라는 확신을 할 수 있습니다. 자동화된 테스트는 특히 잘 사용되지 않는 기능들이 있을 때 유용합니다. 폼과 제출 버튼이 있다고 생각해봅시다. 우리는 폼이 잘 채워지고 제대로 값을 제출하는지는 매번 확인할 것이지만, 모달 창 어느 한 귀퉁이에 숨어있는 체크박스가 잘 동작하는지는 깜빡하고 테스트하지 않을 수도 있습니다. 자동화된 테스트는 이런 일이 일어나지 않도록 해줍니다. 테스트를 자동화해야 할 이유는 또 있습니다. 코드수정에 자신감이 생깁니다. 잘 쓴 테스트코드는 코드를 리팩토링 할 때, 내가 생각하지 못한 다른 무언가를 고장 내지 않는다는 자신감을 주고, 테스트코드를 수정하느라 시간을 낭비하지 않게 해줍니다. 테스트는 그 자체로 문서화의 기능을 합니다. 테스트코드는 그 자체로 코드가 어떻게 동작하고 또 어떻게 동작하도록 짜인 것인지 잘 설명해줍니다. 게다가 테스트코드는 따로 시간을 내서 작업해야 하는 다른 문서들과 달리 개발과정에 속해 있어서 자연스레 항상 최신상태를 유지합니다. 버그와 후퇴를 방지합니다. 발생한 모든 버그에 대해 테스트 케이스를 추가해두면, 그 버그가 다시 발생하지 않으리라는 것을 확신할 수 있습니다. 테스트코드를 작성하는 과정에서 코드를 더 잘 이해할 수 있게 되며, 좀 더 꼼꼼히 코드를 이해하게 되어서, 보통이라면 놓쳤을 만한 이슈들도 찾아낼 수 있습니다. 자동화된 테스트는 버그를 저장소에 커밋하기 전에 잡아서 수정할 수 있게 해주는데, 수동 테스트는 그럴 수 없어서 대부분의 버그를 테스트하는 과정이나 심한 경우 프로덕션 코드에서 발견하게 됩니다. 무엇을 테스트 할 것인가?Mike Cohn이 소개한 테스팅 피라미드는 소프트웨어 테스팅에 있어서 아마 가장 유명한 접근법일 겁니다. 이에 따르면 UI 테스트는 가장 느리며 코드 작성에 큰 비용이 드는 반면, 유닛 테스트는 가장 빠르고 비용이 저렴하므로, UI 테스트보다는 유닛 테스트를 더 많이 작성해야 한다고 합니다. 유닛 테스트는 하나의 함수나 리액트 컴포넌트와 같이, 단일 유닛의 코드를 테스트합니다. 유닛 테스트는 실제 브라우저나 데이터베이스를 사용하지 않기 때문에 아주 빠릅니다. UI 테스트는 실제 브라우저에 로드된 앱 전체를 테스트하고 보통 데이터베이스도 진짜를 사용합니다. 앱의 모든 부분이 제대로 동작하는지 확실히 하기 위해서는 이게 유일한 방법이지만, 너무 오래 걸리며 작성하기도 까다롭습니다. 서비스 테스트는 이 둘의 중간인데, UI 없이 여러 유닛의 통합(Integration)을 테스트합니다. 이러한 전략은 백엔드에서는 잘 통할지 모르나, 프론트엔드 환경에서 UI는 사용자의 흐름을 크게 바꾸지 않으면서도 종종 변화하기 때문에 종종 많은 유닛 테스트에서 에러를 내버립니다. 그래서 우리는 유닛 테스트를 업데이트 하는 데에 많은 시간을 쓰면서도 더 큰 단위인 기능이 제대로 동작할지에 대한 확신을 얻지 못합니다. 어쩌면 프론트엔드는 테스팅에 대해 다른 접근법이 필요한게 아닐까요? Kent C. Dodds의 테스팅 트로피는 프론트엔트 테스트 분야에서 인기를 모으고 있습니다. 그의 주장에 따르면 통합 테스트가 가장 가성비가 좋아서, 다른 테스트보다는 통합 테스트를 많이 작성해야 한다고 합니다. 테스팅 트로피에서의 End-to-End 테스트는 테스팅 피라미드의 UI 테스트와 거의 같습니다. 통합 테스트는 큰 기능들 혹은 전체 페이지를 테스트하는데 이때 실제 백엔드나 데이터베이스 혹은 브라우저를 사용하지 않습니다. 예를 들면 로그인 페이지를 렌더링하고, 사용자 이름과 암호를 입력한 후에 로그인 버튼을 클릭했을 때, 올바른 네트워크 요청이 전송되는지 테스트하지만 실제로 네트워크 요청을 보내지는 않습니다. 이렇게 하는 방법은 나중에 알아볼 예정입니다. 통합 테스트는 작성하는데 꽤 큰 비용이 들지만, 유닛 테스트와 비교하면 몇 가지 장점들이 있습니다. 유닛 테스트 통합 테스트 테스트 하나가 단일 모듈 하나만 커버한다. 테스트 하나가 전체 기능 혹은 페이지 하나를 다 커버한다. 리팩토링 후에 종종 다시 작성해야한다. 대부분 리팩토링 후에도 살아남는다. 테스트에서 세부사항 구현을 피하기 힘들다. 실제 사용자가 앱을 사용하는 방식과 가깝다. 마지막 부분이 중요한데, 통합 테스트는 우리의 앱이 예상한 대로 동작한다는 것을 가장 확실히 보장해줄 수 있습니다. 하지만 그렇다고 통합 테스트만 작성하라는 뜻은 아닙니다. 다른 테스트들도 저마다 필요한 상황이 있습니다. 다만 가장 유용한 테스트에 한정된 자원을 집중할 필요도 있다는 뜻입니다. 테스팅 트로피의 각 단계에 대해서 하나씩 자세히 알아봅시다. 정적 분석은 문법 오류, 나쁜 코드 스타일, 잘못된 API 사용 등의 오류를 잡아냅니다. Prettier와 같은 코드 포매터, ESLint와 같은 린터 그리고 Typescript나 Flow와 같은 타입체커가 사용됩니다. 유닛 테스트는 복잡한 알고리즘이 제대로 동작하는지 확인합니다. Jest를 사용합니다. 통합 테스트는 앱의 모든 기능이 제대로 동작한다는 확신을 줍니다. Jest, Enzyme 혹은 react-testing-library를 사용합니다. E2E 테스트는 앱 전체가 제대로 동작하는지 확인해줍니다. 프론트엔드, 백엔드 그리고 데이터베이스와 그외의 모든 것들이요. Cypress라는 도구를 사용합니다. 저는 Prettier도 테스팅 툴이라고 생각하는데, Prettier는 잘못된 코드는 이상하게 포매팅하고, 그러면 당신은 코드를 다시 한 번 돌아보게 될 것이며, 계속 읽다 보면 버그를 발견할 수도 있기 때문입니다. 이 외에도 유용한 프로젝트마다 유용한 테스트 방법들이 있을 수 있습니다. 모범 사례내부를 테스팅하지마라.폼 컴포넌트가 있다고 가정해봅시다. 이메일 입력과 제출 버튼이 있고, 사용자가 폼을 제출하면 성공 메시지를 보여주는 것을 테스트하고 싶습니다. 테스트코드를 작성해봅시다. 123456test('shows a success message after submission', () =&gt; { const wrapper = mount(&lt;SubscriptionForm /&gt;) wrapper.instance().handleEmailChange('hello@example.com') wrapper.instance().handleSubmit() expect(wrapper.state('isSubmitted')).toBe(true)}) 이 테스트에는 몇 가지 문제가 있습니다. 만약 상태관리 방법을 변경하거나( 예를 들어 state에서 redux나 훅으로 ), 아니면 필드나 메소드 이름 정도만 변경해도 테스트는 깨질 것입니다. 이 테스트는 실제로 사용자 입장에서 폼이 제대로 동작하는지 확인해주지 않습니다. 폼이 handleSubmit 메소드와 연결되어있지 않을 수도 있고, isSubmitted가 true여도 성공 메시지가 출력되지 않을 수도 있습니다. 첫 번째 문제는 false negative 라고 하는데, 이는 실제 동작과 상관없이 테스트에서 실패하는 경우를 의미합니다. 이러한 테스트는 리팩토링을 굉장히 어렵게 만듭니다. 코드를 수정하는 과정에서 무언가 망가뜨린 것인지, 테스트가 잘못된 건지 알 수가 없거든요. 두 번째 문제는 false positive 라고 하고, 이는 위와 반대로 실제로는 실패해야 하는 케이스가 테스트를 통과하는 경우를 의미합니다. 이러한 테스트는 코드가 실제로 사용자 단계에서 제대로 동작하는지에 대한 확신을 전혀 주지 못합니다. 테스트코드를 다시 짜서 문제를 해결해봅시다. 123456test(`shows a success message after submission`, () =&gt; {const {getByLabelText, getByText, getByRole} = render(&lt;SubscriptionForm /&gt;);fireEvent.change(getByLabelText(/email/i, { target: { value: `hello@example.com` } });fireEvent.click(getByText(/submit/i);expect(getByRole(`status`).textContent).toMatch(`Thank you for subscribing!`);}); Kent C. Dodds의 테스팅 구현 세부사항에 대한 글을 읽어 보시면 자세한 내용을 확인하실 수 있습니다. 좋은 테스트는 외적인 동작이 정확하다는 것만 증명하고, 내부가 어떻게 구현되는지 자세한 사항은 몰라도 됩니다. 테스트는 결정적(deterministic)이어야 한다.비결정적인 테스트라고 하면 어떨 때는 통과하고 또 어떨 때는 실패하는 테스트를 의미합니다. 비결정적인 테스트가 생기는 이유는 다음과 같습니다. 서로 다른 타임 존에서 실행되어서, 서로 다른 파일 시스템(특히 다른 경로 구분자)을 사용해서, 테스트 케이스마다 데이터베이스를 제대로 초기화하지 않아서, 상태 값이 여러 테스트 케이스에서 공유되어서, 테스트의 결과가 여러 테스트 케이스들의 실행 순서에 의존적이어서, 비동기적인 작업을 테스트할 때 타임아웃이 발생해서. 이런 비결정적인 테스트의 문제는 polling, 가짜 타이머 혹은 모킹으로 해결할 수 있는데, 앞으로 다음 글에서 알아볼 예정입니다. 좋은 테스트는 결정적이어서 테스트가 실행되는 환경에 상관없이 같은 결과를 내야 합니다. 불필요한 테스트는 하지 마라.이런 테스트코드를 볼 때가 있습니다. 12expect(pizza).toBeDefined()expect(pizza).toHaveAProperty('cheese', 'Mozarella') pizza가 define 되지 않았다면 어차피 두 번째 테스트에서 실패할 것이기 때문에 첫 번째 줄은 필요하지 않습니다. 이런 경우의 jest의 에러메시지는 충분히 이해할만 한 수준이고요. 가끔은 테스트케이스 전체가 불필요한 때도 있습니다. 12test(`error modal is visible`, () =&gt; {})test(`error modal has an error message`, () =&gt; {}) 모달의 에러 메시지가 보인다면 모달 자체도 보인다고 생각할 수 있을 겁니다. 따라서 첫 줄은 삭제해도 됩니다. 좋은 테스트는 불필요하게 중복되는 테스트케이스가 없어야 합니다. 100% 커버리지에 너무 집착하지 마라.모든 코드를 완벽하게 테스트로 커버한다는 건 이론상으로는 훌륭해 보이지만 같지만 실제로는 그렇지 않습니다. 높은 테스트 커버리지를 추구하는 것에는 몇 가지 문제점들이 있습니다. 높은 테스트 커버리지는 안전함에 대한 잘못된 감각을 갖게 합니다. 테스트로 커버된 코드라는 것은 해당 코드가 테스트 중에 실행된다는 뜻이지 해당 코드의 기능을 확실히 테스트한다는 뜻은 아닙니다. 100% 커버리지가 반드시 모든 코드가 제대로 테스팅 되고 있다는 것을 의미하지는 않습니다. 파일 업로드나 드래그앤드랍같은 몇몇 기능은 테스트하기가 정말 어렵습니다. 몇몇 내부작업을 모킹해야하고 결과적으로 실제로 사용자가 당신 앱을 사용하는 환경과는 거리가 생기며 테스트를 유지하기도 어려워집니다. 결국, 점점 덜 유용한 코드를 작성하는데 많은 시간을 들이게 되는 거죠. 경험적으로 봤을 때 100% 커버리지가 유용한 두 가지 경우가 있습니다. 라이브러리를 제작할 때에는 기존의 api를 깨뜨리지 않는 것이 정말 중요하기 때문에 100% 커버리지가 필요합니다. 오픈소스 프로젝트에서는 코드 베이스에 익숙하지 않은 많은 컨트리뷰터가 변화를 주기 때문에 100% 커버리지가 필요합니다. 좋은 테스트는 유지하기 쉬워야 하고, 코드 수정에 자신감을 줘야 합니다. 결론지금까지 프론트엔드 테스트 작성에 있어서 가장 중요한 이론들과 모범사례를 살펴보았습니다. 다른 테스트들 보다는 통합 테스트를 많이 작성해라 내부 테스트를 지양해라. 테스트는 결정적이어야 한다. 불필요한 테스트는 하지 마라. 100% 커버리지에 너무 집착하지 마라. 이제 실제로 테스트코드를 작성할 준비가 끝났습니다. 시리즈의 다음 글들은 두 갈래로 나뉘는 글이기 때문에, Enzyme 이든 React Testing Libary 이든 마음에 드는 도구에 관한 글을 선택해서 하나만 읽으셔도 괜찮습니다. 아직 어떤 도구를 골라야 할 지 모르겠다면 각 글의 초입에 해당 도구의 장·단점이 설명되어있으니 선택하는 데 도움이 될 수 있을 것입니다.","link":"/frontend/modern-react-testing/first/"}],"tags":[{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"prettier","slug":"prettier","link":"/tags/prettier/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"dom","slug":"dom","link":"/tags/dom/"},{"name":"tranlated","slug":"tranlated","link":"/tags/tranlated/"},{"name":"gatsby","slug":"gatsby","link":"/tags/gatsby/"},{"name":"gh-pages","slug":"gh-pages","link":"/tags/gh-pages/"},{"name":"react-native","slug":"react-native","link":"/tags/react-native/"},{"name":"codepush","slug":"codepush","link":"/tags/codepush/"},{"name":"storybook","slug":"storybook","link":"/tags/storybook/"},{"name":"testing","slug":"testing","link":"/tags/testing/"},{"name":"translated","slug":"translated","link":"/tags/translated/"}],"categories":[{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"frontend","slug":"frontend","link":"/categories/frontend/"},{"name":"logs","slug":"logs","link":"/categories/logs/"},{"name":"mobile","slug":"mobile","link":"/categories/mobile/"}]}